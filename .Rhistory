}
getResults('0xfe9fb8c73303fb0d81c4b843630bd3b063180d08cbcfd761dfdf5e1f015d3dcf')
library(rjson)
library(encryptr)
library(httr)
library(R.utils)
delegate <- function(cmd, async = F, useEncryption = T) {
# get command as a string
str = substitute(cmd)
# get elements from the string command as a list
str.list = as.list(str)
# get rid of unnamed elements from the string
elem.list = str.list[names(str.list) != '']
# get rid of string variables
elem.list = elem.list[lapply(elem.list, is.character) == F]
# get rid of boolean variables
elem.list = elem.list[lapply(elem.list, is.logical) == F]
# get rid of numeric variables
elem.list = elem.list[lapply(elem.list, is.numeric) == F]
values.list = lapply(elem.list, function(e) {
get(deparse(e))
})
names(values.list) = elem.list
save(values.list, file = 'data.Rdata')
currentTimestamp = as.integer(Sys.time())
encryptedFileName = paste(currentTimestamp,
'.data.Rdata',
'.encryptr.bin',
sep = '')
encryptResult = encrypt_file('data.Rdata',
crypt_file_name = encryptedFileName,
public_key_path = 'id_rsa_iexec.pub')
r = POST('localhost:3000/api/jobs',
body = list(
command=paste(deparse(str), collapse = " "),
publicKey=upload_file('id_rsa.pub'),
rdata=upload_file(encryptedFileName)))
file.remove('data.Rdata', encryptedFileName)
c = content(r)
return(c$data$job$`_doc`$deal$tasks[[1]])
}
getResults <- function(taskId) {
resultAvailable = FALSE
while (resultAvailable == FALSE) {
r = GET(paste('localhost:3000/api/tasks/', taskId, '/file', sep = ''))
c = content(r)
resultAvailable = c$resultsAvailable
if(resultAvailable == TRUE) {
curl::curl_download(
url = paste(
'https://gateway.pinata.cloud/ipfs/',
c$data$result$upload$IpfsHash,
sep = ''),
destfile = "result.Rdata.encryptr.bin.gz")
curl::curl_download(
url = paste(
'https://gateway.pinata.cloud/ipfs/',
c$data$output$upload$IpfsHash,
sep = ''),
destfile = "output.encryptr.bin.gz")
gunzip('result.Rdata.encryptr.bin.gz')
gunzip('output.encryptr.bin.gz')
decrypt_file('result.Rdata.encryptr.bin',
file_name = 'result.Rdata',
private_key_path = 'id_rsa')
decrypt_file('output.encryptr.bin',
file_name = 'output',
private_key_path = 'id_rsa')
load('result.Rdata', envir = .GlobalEnv)
file.remove('result.Rdata',
'result.Rdata.encryptr.bin',
'output',
'output.encryptr.bin')
}
else {
Sys.sleep(time = 20)
}
}
}
pacman::p_load(caret, tidyverse, readr, readxl, parallel, doParallel, gridExtra, plyr, pso, GA, DEoptim, GGally, xgboost, broom, knitr, kableExtra, tictoc, install = T)
# Import Data
concrete_data <- read_xls(path = "./../../Concrete_Data.xls", sheet = 1)
# Rename variables
colnames(concrete_data) <- c("Cement", "Slag", "Ash", "Water", "Superplasticizer", "Coarse_Aggregate", "Fine_Aggregate", "Age", "Strength")
# Recalculate composition as proportions ranging from 0 to 1
concrete_data[, 1:7] <- t(apply(X = concrete_data[, 1:7], MARGIN = 1, FUN = function(x) {x/sum(x)}))
# Remove any observations with missing values
concrete_data <- concrete_data[complete.cases(concrete_data), ]
# Average the values of compressive strength of replicate experiments
concrete_data <- ddply(.data = concrete_data,
.variables = .(Cement, Slag, Ash, Water, Superplasticizer, `Coarse_Aggregate`, `Fine_Aggregate`, Age),
.fun = function(x) c(Strength = mean(x$Strength)))
# Create training and test set using stratified partioning
set.seed(1)
training_index <- createDataPartition(y = concrete_data$Strength, p = 0.80)[[1]]
training_set <- concrete_data[training_index, ]
test_set <- concrete_data[-training_index, ]
# Training Parameters
CV_folds <- 5 # number of folds
CV_repeats <- 3 # number of repeats
minimum_resampling <- 5 # minimum number of resamples
# Training Settings
set.seed(1)
# trainControl object for standard repeated cross-validation
train_control <- caret::trainControl(method = "repeatedcv", number = CV_folds, repeats = CV_repeats,
verboseIter = FALSE, returnData = FALSE)
# trainControl object for repeated cross-validation with grid search
adapt_control_grid <- caret::trainControl(method = "adaptive_cv", number = CV_folds, repeats = CV_repeats,
adaptive = list(min = minimum_resampling, # minimum number of resamples tested before model is excluded
alpha = 0.05, # confidence level used to exclude parameter settings
method = "gls", # generalized least squares
complete = TRUE),
search = "grid", # execute grid search
verboseIter = FALSE, returnData = FALSE)
# trainControl object for repeated cross-validation with random search
adapt_control_random <- caret::trainControl(method = "adaptive_cv", number = CV_folds, repeats = CV_repeats,
adaptive = list(min = minimum_resampling, # minimum number of resamples tested before model is excluded
alpha = 0.05, # confidence level used to exclude parameter settings
method = "gls", # generalized least squares
complete = TRUE),
search = "random", # execute random search
verboseIter = FALSE, returnData = FALSE)
# Create grid
XGBoost_Linear_grid <- expand.grid(
nrounds = c(50, 100), # number of boosting iterations
eta = c(0.01, 0.1),  # learning rate, low value means model is more robust to overfitting
lambda = c(0.1, 0.5), # L2 Regularization (Ridge Regression)
alpha =  c(0.1, 0.5) # L1 Regularization (Lasso Regression)
)
task = delegate(caret::train(Strength ~.,
data = training_set,
method = "xgbLinear",
trControl = adapt_control_grid,
verbose = FALSE,
silent = 1,
# tuneLength = 20
tuneGrid = XGBoost_Linear_grid
))
getResults(task)
getResults <- function(taskId) {
resultAvailable = FALSE
while (resultAvailable == FALSE) {
r = GET(paste('localhost:3000/api/tasks/', taskId, '/file', sep = ''))
c = content(r)
c
resultAvailable = c$resultsAvailable
if(resultAvailable == TRUE) {
curl::curl_download(
url = paste(
'https://gateway.pinata.cloud/ipfs/',
c$data$result$upload$IpfsHash,
sep = ''),
destfile = "result.Rdata.encryptr.bin.gz")
curl::curl_download(
url = paste(
'https://gateway.pinata.cloud/ipfs/',
c$data$output$upload$IpfsHash,
sep = ''),
destfile = "output.encryptr.bin.gz")
gunzip('result.Rdata.encryptr.bin.gz')
gunzip('output.encryptr.bin.gz')
decrypt_file('result.Rdata.encryptr.bin',
file_name = 'result.Rdata',
private_key_path = 'id_rsa')
decrypt_file('output.encryptr.bin',
file_name = 'output',
private_key_path = 'id_rsa')
load('result.Rdata', envir = .GlobalEnv)
file.remove('result.Rdata',
'result.Rdata.encryptr.bin',
'output',
'output.encryptr.bin')
}
else {
Sys.sleep(time = 20)
}
}
}
getResults(task)
getResults <- function(taskId) {
resultAvailable = FALSE
while (resultAvailable == FALSE) {
r = GET(paste('localhost:3000/api/tasks/', taskId, '/file', sep = ''))
c = content(r)
print(c)
resultAvailable = c$resultsAvailable
if(resultAvailable == TRUE) {
curl::curl_download(
url = paste(
'https://gateway.pinata.cloud/ipfs/',
c$data$result$upload$IpfsHash,
sep = ''),
destfile = "result.Rdata.encryptr.bin.gz")
curl::curl_download(
url = paste(
'https://gateway.pinata.cloud/ipfs/',
c$data$output$upload$IpfsHash,
sep = ''),
destfile = "output.encryptr.bin.gz")
gunzip('result.Rdata.encryptr.bin.gz')
gunzip('output.encryptr.bin.gz')
decrypt_file('result.Rdata.encryptr.bin',
file_name = 'result.Rdata',
private_key_path = 'id_rsa')
decrypt_file('output.encryptr.bin',
file_name = 'output',
private_key_path = 'id_rsa')
load('result.Rdata', envir = .GlobalEnv)
file.remove('result.Rdata',
'result.Rdata.encryptr.bin',
'output',
'output.encryptr.bin')
}
else {
Sys.sleep(time = 20)
}
}
}
getResults(task)
delegate <- function(cmd, async = F, useEncryption = T) {
# get command as a string
str = substitute(cmd)
# get elements from the string command as a list
str.list = as.list(str)
# get rid of unnamed elements from the string
elem.list = str.list[names(str.list) != '']
# get rid of string variables
elem.list = elem.list[lapply(elem.list, is.character) == F]
# get rid of boolean variables
elem.list = elem.list[lapply(elem.list, is.logical) == F]
# get rid of numeric variables
elem.list = elem.list[lapply(elem.list, is.numeric) == F]
values.list = lapply(elem.list, function(e) {
get(deparse(e))
})
names(values.list) = elem.list
save(values.list, file = 'data.Rdata')
currentTimestamp = as.integer(Sys.time())
encryptedFileName = paste(currentTimestamp,
'.data.Rdata',
'.encryptr.bin',
sep = '')
encryptResult = encrypt_file('data.Rdata',
crypt_file_name = encryptedFileName,
public_key_path = 'id_rsa_iexec.pub')
r = POST('localhost:3000/api/jobs',
body = list(
command=paste(deparse(str), collapse = " "),
publicKey=upload_file('id_rsa.pub'),
rdata=upload_file(encryptedFileName)))
file.remove('data.Rdata', encryptedFileName)
c = content(r)
return(c)
# return(c$data$job$`_doc`$deal$tasks[[1]])
}
getResults <- function(taskId) {
resultAvailable = FALSE
while (resultAvailable == FALSE) {
r = GET(paste('localhost:3000/api/tasks/', taskId, '/file', sep = ''))
c = content(r)
print(c)
resultAvailable = c$resultsAvailable
if(resultAvailable == TRUE) {
curl::curl_download(
url = paste(
'https://gateway.pinata.cloud/ipfs/',
c$data$result$upload$IpfsHash,
sep = ''),
destfile = "result.Rdata.encryptr.bin.gz")
curl::curl_download(
url = paste(
'https://gateway.pinata.cloud/ipfs/',
c$data$output$upload$IpfsHash,
sep = ''),
destfile = "output.encryptr.bin.gz")
gunzip('result.Rdata.encryptr.bin.gz')
gunzip('output.encryptr.bin.gz')
decrypt_file('result.Rdata.encryptr.bin',
file_name = 'result.Rdata',
private_key_path = 'id_rsa')
decrypt_file('output.encryptr.bin',
file_name = 'output',
private_key_path = 'id_rsa')
load('result.Rdata', envir = .GlobalEnv)
file.remove('result.Rdata',
'result.Rdata.encryptr.bin',
'output',
'output.encryptr.bin')
}
else {
Sys.sleep(time = 20)
}
}
}
task = delegate(caret::train(Strength ~.,
data = training_set,
method = "xgbLinear",
trControl = adapt_control_grid,
verbose = FALSE,
silent = 1,
# tuneLength = 20
tuneGrid = XGBoost_Linear_grid
))
task$data$job$deal$tasks[[1]]
delegate <- function(cmd, async = F, useEncryption = T) {
# get command as a string
str = substitute(cmd)
# get elements from the string command as a list
str.list = as.list(str)
# get rid of unnamed elements from the string
elem.list = str.list[names(str.list) != '']
# get rid of string variables
elem.list = elem.list[lapply(elem.list, is.character) == F]
# get rid of boolean variables
elem.list = elem.list[lapply(elem.list, is.logical) == F]
# get rid of numeric variables
elem.list = elem.list[lapply(elem.list, is.numeric) == F]
values.list = lapply(elem.list, function(e) {
get(deparse(e))
})
names(values.list) = elem.list
save(values.list, file = 'data.Rdata')
currentTimestamp = as.integer(Sys.time())
encryptedFileName = paste(currentTimestamp,
'.data.Rdata',
'.encryptr.bin',
sep = '')
encryptResult = encrypt_file('data.Rdata',
crypt_file_name = encryptedFileName,
public_key_path = 'id_rsa_iexec.pub')
r = POST('localhost:3000/api/jobs',
body = list(
command=paste(deparse(str), collapse = " "),
publicKey=upload_file('id_rsa.pub'),
rdata=upload_file(encryptedFileName)))
file.remove('data.Rdata', encryptedFileName)
c = content(r)
return(c$data$job$deal$tasks[[1]])
}
delegate <- function(cmd, async = F, useEncryption = T) {
# get command as a string
str = substitute(cmd)
# get elements from the string command as a list
str.list = as.list(str)
# get rid of unnamed elements from the string
elem.list = str.list[names(str.list) != '']
# get rid of string variables
elem.list = elem.list[lapply(elem.list, is.character) == F]
# get rid of boolean variables
elem.list = elem.list[lapply(elem.list, is.logical) == F]
# get rid of numeric variables
elem.list = elem.list[lapply(elem.list, is.numeric) == F]
values.list = lapply(elem.list, function(e) {
get(deparse(e))
})
names(values.list) = elem.list
save(values.list, file = 'data.Rdata')
currentTimestamp = as.integer(Sys.time())
encryptedFileName = paste(currentTimestamp,
'.data.Rdata',
'.encryptr.bin',
sep = '')
encryptResult = encrypt_file('data.Rdata',
crypt_file_name = encryptedFileName,
public_key_path = 'id_rsa_iexec.pub')
r = POST('localhost:3000/api/jobs',
body = list(
command=paste(deparse(str), collapse = " "),
publicKey=upload_file('id_rsa.pub'),
rdata=upload_file(encryptedFileName)))
file.remove('data.Rdata', encryptedFileName)
c = content(r)
return(c$data$job$deal$tasks[[1]])
}
getResults <- function(taskId) {
resultAvailable = FALSE
while (resultAvailable == FALSE) {
r = GET(paste('localhost:3000/api/tasks/', taskId, '/file', sep = ''))
c = content(r)
print(c)
resultAvailable = c$resultsAvailable
if(resultAvailable == TRUE) {
curl::curl_download(
url = paste(
'https://gateway.pinata.cloud/ipfs/',
c$data$result$upload$IpfsHash,
sep = ''),
destfile = "result.Rdata.encryptr.bin.gz")
curl::curl_download(
url = paste(
'https://gateway.pinata.cloud/ipfs/',
c$data$output$upload$IpfsHash,
sep = ''),
destfile = "output.encryptr.bin.gz")
gunzip('result.Rdata.encryptr.bin.gz')
gunzip('output.encryptr.bin.gz')
decrypt_file('result.Rdata.encryptr.bin',
file_name = 'result.Rdata',
private_key_path = 'id_rsa')
decrypt_file('output.encryptr.bin',
file_name = 'output',
private_key_path = 'id_rsa')
load('result.Rdata', envir = .GlobalEnv)
file.remove('result.Rdata',
'result.Rdata.encryptr.bin',
'output',
'output.encryptr.bin')
}
else {
Sys.sleep(time = 20)
}
}
}
task = delegate(caret::train(Strength ~.,
data = training_set,
method = "xgbLinear",
trControl = adapt_control_grid,
verbose = FALSE,
silent = 1,
# tuneLength = 20
tuneGrid = XGBoost_Linear_grid
))
getResults(task)
getResults <- function(taskId) {
resultAvailable = FALSE
while (resultAvailable == FALSE) {
r = GET(paste('localhost:3000/api/tasks/', taskId, '/file', sep = ''))
c = content(r)
c
resultAvailable = c$resultsAvailable
if(resultAvailable == TRUE) {
curl::curl_download(
url = paste(
'https://gateway.pinata.cloud/ipfs/',
c$data$result$upload$IpfsHash,
sep = ''),
destfile = "result.Rdata.encryptr.bin.gz")
curl::curl_download(
url = paste(
'https://gateway.pinata.cloud/ipfs/',
c$data$output$upload$IpfsHash,
sep = ''),
destfile = "output.encryptr.bin.gz")
gunzip('result.Rdata.encryptr.bin.gz')
gunzip('output.encryptr.bin.gz')
decrypt_file('result.Rdata.encryptr.bin',
file_name = 'result.Rdata',
private_key_path = 'id_rsa')
decrypt_file('output.encryptr.bin',
file_name = 'output',
private_key_path = 'id_rsa')
load('result.Rdata', envir = .GlobalEnv)
file.remove('result.Rdata',
'result.Rdata.encryptr.bin',
'output',
'output.encryptr.bin')
}
else {
Sys.sleep(time = 20)
}
}
}
getResults(task)
getResults <- function(taskId) {
resultAvailable = FALSE
while (resultAvailable == FALSE) {
r = GET(paste('localhost:3000/api/tasks/', taskId, '/file', sep = ''))
c = content(r)
resultAvailable = c$resultsAvailable
if(resultAvailable == TRUE) {
curl::curl_download(
url = paste(
'https://gateway.pinata.cloud/ipfs/',
c$data$result$upload$IpfsHash,
sep = ''),
destfile = "result.Rdata.encryptr.bin.gz")
curl::curl_download(
url = paste(
'https://gateway.pinata.cloud/ipfs/',
c$data$output$upload$IpfsHash,
sep = ''),
destfile = "output.encryptr.bin.gz")
gunzip('result.Rdata.encryptr.bin.gz')
gunzip('output.encryptr.bin.gz')
decrypt_file('result.Rdata.encryptr.bin',
file_name = 'result.Rdata',
private_key_path = 'id_rsa')
decrypt_file('output.encryptr.bin',
file_name = 'output',
private_key_path = 'id_rsa')
load('result.Rdata', envir = .GlobalEnv)
file.remove('result.Rdata',
'result.Rdata.encryptr.bin',
'output',
'output.encryptr.bin')
}
else {
Sys.sleep(time = 20)
}
}
}
install.packages("roxygen2")
getwd()
setwd('/Volumes/MacintoshHD/Users/Andy/R/')
delegate::deleg(mean(c(4,2,1)))
delegate::deleg(mean(c(4,2,1)))
library(delegate)
deleg(mean(c(4,2,1)))
library(delegate)
deleg(mean(c(4,2,1)))
library(delegate)
deleg(mean(c(4,2,1)))
